<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>baizn的github博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="baizn的github博客">
<meta property="og:url" content="http://baizn.github.io/index.html">
<meta property="og:site_name" content="baizn的github博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="baizn的github博客">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="baizn的github博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">baizn</a></h1>
		</hgroup>

		
				


		
			<div id="switch-btn" class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div id="switch-area" class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives/">所有文章</a></li>
				        
							<li><a href="/tags/">标签云</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<ul class="social">
							
								<li id="Email"><a class="Email" target="_blank" href="/baizhanning@zhubajie.com" title="Email"></a></li>
					        
								<li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/baizn/baizn.github.io" title="GitHub"></a></li>
					        
								<li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
					        
						</ul>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/API/" style="font-size: 12px;">API</a> <a href="/tags/Ajax/" style="font-size: 10px;">Ajax</a> <a href="/tags/BFC/" style="font-size: 10px;">BFC</a> <a href="/tags/CORS/" style="font-size: 10px;">CORS</a> <a href="/tags/CSS/" style="font-size: 12px;">CSS</a> <a href="/tags/Cache/" style="font-size: 10px;">Cache</a> <a href="/tags/Component/" style="font-size: 12px;">Component</a> <a href="/tags/Cookie/" style="font-size: 10px;">Cookie</a> <a href="/tags/Document/" style="font-size: 10px;">Document</a> <a href="/tags/Drag/" style="font-size: 10px;">Drag</a> <a href="/tags/ECMAScript/" style="font-size: 14px;">ECMAScript</a> <a href="/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/tags/ES6/" style="font-size: 10px;">ES6+</a> <a href="/tags/Element/" style="font-size: 10px;">Element</a> <a href="/tags/Float/" style="font-size: 10px;">Float</a> <a href="/tags/Flux/" style="font-size: 10px;">Flux</a> <a href="/tags/Function/" style="font-size: 10px;">Function</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/MEAT/" style="font-size: 10px;">MEAT</a> <a href="/tags/Middleware/" style="font-size: 10px;">Middleware</a> <a href="/tags/Object/" style="font-size: 10px;">Object</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/Props/" style="font-size: 12px;">Props</a> <a href="/tags/React/" style="font-size: 18px;">React</a> <a href="/tags/React-router/" style="font-size: 10px;">React-router</a> <a href="/tags/React组件/" style="font-size: 10px;">React组件</a> <a href="/tags/React顶层API/" style="font-size: 10px;">React顶层API</a> <a href="/tags/Redux/" style="font-size: 16px;">Redux</a> <a href="/tags/SPA/" style="font-size: 10px;">SPA</a> <a href="/tags/Thunk/" style="font-size: 10px;">Thunk</a> <a href="/tags/action/" style="font-size: 10px;">action</a> <a href="/tags/after伪元素/" style="font-size: 10px;">after伪元素</a> <a href="/tags/alt/" style="font-size: 10px;">alt</a> <a href="/tags/ant-design/" style="font-size: 10px;">ant-design</a> <a href="/tags/async/" style="font-size: 10px;">async</a> <a href="/tags/clearfix/" style="font-size: 10px;">clearfix</a> <a href="/tags/codeSplitting/" style="font-size: 10px;">codeSplitting</a> <a href="/tags/componentWillReceiveProps/" style="font-size: 10px;">componentWillReceiveProps</a> <a href="/tags/div/" style="font-size: 10px;">div</a> <a href="/tags/div拖拽/" style="font-size: 10px;">div拖拽</a> <a href="/tags/instanceof/" style="font-size: 10px;">instanceof</a> <a href="/tags/meat/" style="font-size: 10px;">meat</a> <a href="/tags/prototype/" style="font-size: 10px;">prototype</a> <a href="/tags/reducer/" style="font-size: 10px;">reducer</a> <a href="/tags/referrer/" style="font-size: 10px;">referrer</a> <a href="/tags/server-render/" style="font-size: 10px;">server render</a> <a href="/tags/state/" style="font-size: 12px;">state</a> <a href="/tags/store/" style="font-size: 10px;">store</a> <a href="/tags/type-file/" style="font-size: 10px;">type=file</a> <a href="/tags/typeof/" style="font-size: 10px;">typeof</a> <a href="/tags/webpack/" style="font-size: 12px;">webpack</a> <a href="/tags/事件处理/" style="font-size: 10px;">事件处理</a> <a href="/tags/优化/" style="font-size: 10px;">优化</a> <a href="/tags/优缺点/" style="font-size: 10px;">优缺点</a> <a href="/tags/作用域/" style="font-size: 10px;">作用域</a> <a href="/tags/单页面Web应用/" style="font-size: 10px;">单页面Web应用</a> <a href="/tags/原型链/" style="font-size: 10px;">原型链</a> <a href="/tags/可复用组件/" style="font-size: 10px;">可复用组件</a> <a href="/tags/坐标/" style="font-size: 10px;">坐标</a> <a href="/tags/垃圾回收/" style="font-size: 10px;">垃圾回收</a> <a href="/tags/实例/" style="font-size: 10px;">实例</a> <a href="/tags/客户端/" style="font-size: 10px;">客户端</a> <a href="/tags/对象/" style="font-size: 10px;">对象</a> <a href="/tags/异步/" style="font-size: 10px;">异步</a> <a href="/tags/引用类型/" style="font-size: 10px;">引用类型</a> <a href="/tags/执行环境/" style="font-size: 10px;">执行环境</a> <a href="/tags/数据流/" style="font-size: 10px;">数据流</a> <a href="/tags/服务端渲染/" style="font-size: 10px;">服务端渲染</a> <a href="/tags/术语/" style="font-size: 10px;">术语</a> <a href="/tags/样式修改/" style="font-size: 10px;">样式修改</a> <a href="/tags/检测/" style="font-size: 10px;">检测</a> <a href="/tags/清除浮动/" style="font-size: 10px;">清除浮动</a> <a href="/tags/状态/" style="font-size: 10px;">状态</a> <a href="/tags/生命周期/" style="font-size: 12px;">生命周期</a> <a href="/tags/类型检测/" style="font-size: 10px;">类型检测</a> <a href="/tags/纯函数/" style="font-size: 10px;">纯函数</a> <a href="/tags/组件/" style="font-size: 10px;">组件</a> <a href="/tags/继承/" style="font-size: 10px;">继承</a> <a href="/tags/翻译/" style="font-size: 14px;">翻译</a> <a href="/tags/自动分号插入/" style="font-size: 10px;">自动分号插入</a> <a href="/tags/跨域/" style="font-size: 10px;">跨域</a> <a href="/tags/跨浏览器/" style="font-size: 10px;">跨浏览器</a> <a href="/tags/连续赋值/" style="font-size: 10px;">连续赋值</a> <a href="/tags/遇到的问题/" style="font-size: 10px;">遇到的问题</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">人活着如果没有梦想，那和咸鱼还有什么区别－－－专注于前端, 专注于JavaScript</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">baizn</a></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<a href="/" class="profilepic">
				<img lazy-src="/img/avatar.png" class="js-avatar">
			</a>
			<hgroup>
			  <h1 class="header-author"><a href="/" title="回到主页">baizn</a></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives/">所有文章</a></li>
		        
					<li><a href="/tags/">标签云</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
						<ul class="social">
							
								<li id="Email"><a class="Email" target="_blank" href="/baizhanning@zhubajie.com" title="Email"></a></li>
					        
								<li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/baizn/baizn.github.io" title="GitHub"></a></li>
					        
								<li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
					        
						</ul>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-React服务端渲染" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/18/React服务端渲染/" class="article-date">
  	<time datetime="2016-03-18T06:43:39.000Z" itemprop="datePublished">2016-03-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/18/React服务端渲染/">React服务端渲染</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>服务端渲染作用</p>
</blockquote>
<ul>
<li>便于SEO，可降低首屏加载时间</li>
</ul>
<blockquote>
<p>服务端渲染原理</p>
</blockquote>
<ul>
<li>service与client共享一部分代码</li>
<li>server拿到首次渲染需要的初始化数据state</li>
<li>server根据state把组件转换为HTML字符串</li>
<li>server把HTML和state发到客户端</li>
</ul>
<p>React提供了renderToString和renderToStaticMarkup两个方法，它们支持将React Component直接输出成HTML字符串。因此，可以在服务端执行React，然后将渲染结果返回。</p>
<h3 id="1_renderToString_&amp;_renderToStaticMarkup">1 renderToString &amp; renderToStaticMarkup</h3><ul>
<li>renderToString</li>
</ul>
<blockquote>
<p>用在服务端，把React Component渲染成HTML，然后通过response发送到浏览器端，达到SEO的目的</p>
</blockquote>
<ul>
<li>renderToStaticMarkup</li>
</ul>
<blockquote>
<p>和renderToString类似，但它生成的HTML中不包含类似data-react-id这样的属性，可用于生成简单的静态页面。</p>
</blockquote>
<p>还需要考虑以下问题：</p>
<ul>
<li><p>初始数据异步请求：所有需要在服务端渲染的数据请求，都需要在返回HTML之前处理完</p>
</li>
<li><p>Action和Store该如何管理？Action事件发送是在数据之前还是之后？</p>
</li>
<li><p>服务端数据需要初始化，浏览器端数据也需要初始化。所以浏览器端需要保存一个副本，该副本如何保存，浏览器端Store如何初始化？</p>
</li>
<li><p>前后端代码共享</p>
</li>
<li><p>前后端路由统一处理</p>
</li>
</ul>
<h3 id="2_服务端渲染与状态共享">2 服务端渲染与状态共享</h3><p>在设计服务端渲染组件时，应考虑如何将state传递到客户端，以便充分利用服务端渲染的优势，同时也要保证同一个props传递到组件中，总会输出相同的渲染结果。</p>
<h4 id="2-1_checksum的失效">2.1 checksum的失效</h4><p>如下组件，在服务端渲染，每次都会输出一个随机数。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloComponent = React.createClass(&#123;</span><br><span class="line">	render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &lt;div&gt;&#123;Math.random()&#125;&lt;div&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> html = ReactDOMServer.renderToString(&lt;HelloComponent /&gt;);</span><br></pre></td></tr></table></figure>
<p>这个组件会导致data-react-checksum值检测失败，React会抛弃服务端的渲染结果，而在客户端重新进行渲染，这样就失去了服务端渲染的优势。</p>
<h4 id="2-2_解决方案">2.2 解决方案</h4><p>对该组件进行重构，将随机数封装到props中，将props传递到客户端共享状态。</p>
<ul>
<li>重构组件</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloComponent = React.createClass(&#123;</span><br><span class="line">	render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &lt;div&gt;&#123;<span class="keyword">this</span>.props.number&#125;&lt;div&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>服务端渲染</li>
</ul>
<p>服务端渲染组件后，除了渲染的HTML传递到页面外，还要将客户端使用的props传递到页面。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = Math.random();</span><br><span class="line"><span class="comment">//server render</span></span><br><span class="line"><span class="keyword">var</span> html = ReactDOMServer.renderToString(&lt;HelloComponent number=&#123;<span class="built_in">num</span>&#125; /&gt;);</span><br><span class="line"><span class="comment">//向页面传递渲染后HTML字符串和num(props)</span></span><br><span class="line">res.render(<span class="string">'random-props'</span>, &#123;html: html, <span class="built_in">num</span>: <span class="built_in">num</span>&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>客户端渲染</li>
</ul>
<p>客户端会在页面加载完成，使用服务端传递的props重新渲染组件，由于前后端的props值相同，React的checksum检测就会通过。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HelloComponent <span class="keyword">from</span> <span class="string">'./HelloComponent'</span>;</span><br><span class="line"><span class="keyword">var</span> mountNode = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line"><span class="comment">//使用服务端传递初始值重新渲染组件</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="title">HelloComponent</span> <span class="attribute">number</span>=<span class="value">&#123;props.num&#125;</span> /&gt;</span>, mountNode);</span></span><br></pre></td></tr></table></figure>
<h3 id="3_服务端使用Redux">3 服务端使用Redux</h3><ul>
<li>Store</li>
</ul>
<blockquote>
<p>整个应用只有一个唯一的Store</p>
<p>Store对应的状态树（state），由reducer函数生成</p>
<p>state树的每个字段都可以进一步由不同的reducer函数生成</p>
<p>Store包含dispatch、getState等方法来处理数据流</p>
<p>Store的state树只能由dispatch(action)来触发更改</p>
</blockquote>
<ul>
<li>redux的数据流</li>
</ul>
<blockquote>
<p>action是一个包含{ type, payload }的对象</p>
<p>reducer函数通过store.dispatch(action)触发</p>
<p>reducer函数接收（state，action）两个参数，返回一个新的state</p>
<p>reducer函数判断action.type，然后处理对应的action.payload数据来更新state树</p>
</blockquote>
<ul>
<li>从服务端把数据发送到客户端，需要以下步骤</li>
</ul>
<blockquote>
<p>为每次请求创建全新的Redux store实例</p>
<p>按需dispatch(action)</p>
<p>从store中获取state</p>
<p>把state一同返回给客户端</p>
</blockquote>
<p>在客户端，使用服务端返回的state创建并初始化一个全新的Redux store。</p>
<p>Redux在服务端唯一要做的事情就是：提供应用所需的初始state。</p>
<h4 id="3-1_服务端">3.1 服务端</h4><p>Redux服务端渲染流程：</p>
<ul>
<li>获取store</li>
<li>获取初始化state</li>
<li>用renderToString注入到模板中，初始化state存到window对象中，在客户端使用window._initial_state获取</li>
<li>发送注入模板后的字符串到客户端</li>
</ul>
<h3 id="4_服务端开发">4 服务端开发</h3><blockquote>
<p>server.js</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'./reducers'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./containers/App'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次请求都会触发</span></span><br><span class="line">app.use(handleRender);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRender</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderFullPage</span>(<span class="params">html, initialState</span>) </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.listen(port);</span><br></pre></td></tr></table></figure>
<h4 id="4-1_处理请求">4.1 处理请求</h4><p>每次请求都创建一个新的Redux store实例，该store的唯一作用是提供应用初始的state。</p>
<p>渲染时，使用<provider>包住根组件<app>，让组件树中所有组件都能访问到store。</app></provider></p>
<p>服务端渲染最关键的一步是在发送响应前渲染初始的HTML，使用renderToString()方法。</p>
<p>然后使用store.getState()从store得到初始state。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRender</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//创建新的Redux store实例</span></span><br><span class="line">	<span class="keyword">const</span> store = createStore(rootReducer);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//把组件渲染成字符串</span></span><br><span class="line">	<span class="keyword">const</span> html = renderToString(</span><br><span class="line">		<span class="xml"><span class="tag">&lt;<span class="title">Provider</span> <span class="attribute">store</span>=<span class="value">&#123;store&#125;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">App</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">Provider</span>&gt;</span></span><br><span class="line">	)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从store中获得初始state</span></span><br><span class="line">	<span class="keyword">const</span> initialState = store.getState();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//把渲染后的页面内容发送到客户端</span></span><br><span class="line">	res.send(renderFullPage(html, initialState));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2_注入初始组件的HTML和State">4.2 注入初始组件的HTML和State</h4><p>服务端渲染最后一步是把初始组件的HTML和初始state注入到客户端能够渲染的模板中。</p>
<ul>
<li>如何传递state呢？</li>
</ul>
<blockquote>
<p>添加一个<script>标签，把initialState赋给window._INITIAL<em>STATE</em>，客户端通过window._INITIAL<em>STATE</em>获取initialState。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function renderFullPage(html, initialState) &#123;</span><br><span class="line">	return `</span><br><span class="line">		<span class="doctype">&lt;!doctype html&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">title</span>&gt;</span>react server render<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">'container'</span>&gt;</span>$&#123;html&#125;<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">					<span class="built_in">window</span>._INITIAL_STATE_ = $&#123;<span class="built_in">JSON</span>.stringify(initialState)&#125;</span><br><span class="line">				</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">'/build/bundle.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br><span class="line">	`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6_客户端开发">6 客户端开发</h3><p>客户端只需要从window._INITIAL<em>STATE</em>得到初始state，并传给createStore()函数即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./container/App'</span>;</span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'./reducers'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过服务端注入的初始state</span></span><br><span class="line"><span class="keyword">const</span> initialState = <span class="built_in">window</span>._INITIAL_STATE_;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用初始state创建Redux store</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer, initialState);</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="title">Provider</span> <span class="attribute">store</span>=<span class="value">&#123;store&#125;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">App</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">Provider</span>&gt;</span>,</span><br><span class="line">	document.querySelector('#container')</span><br><span class="line">)</span></span><br></pre></td></tr></table></figure>
<p>以上就是实现服务端渲染的所有步骤，但也只会用动态代码渲染一个静态view。</p>
<h3 id="7_如何动态创建state渲染动态view？">7 如何动态创建state渲染动态view？</h3><p>客户端只执行收到的代码，刚开始的初始state可能是空的，然后根据需要获取state。在服务端，渲染是同步执行的而且我们只有一次渲染view的机会。在收到请求时，可能需要根据请求参数或者外部state（如API请求或访问数据库），计算后得到初始state。</p>
<h4 id="7-1_处理Request参数">7.1 处理Request参数</h4><p>服务端收到的唯一输入是浏览器的请求。</p>
<blockquote>
<p>server.js</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">'qs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRender</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//如果存在的话，从request读取参数</span></span><br><span class="line">	<span class="keyword">const</span> params = qs.parse(req.query);</span><br><span class="line">	<span class="keyword">const</span> counter = <span class="built_in">parseInt</span>(params.counter) || <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//得到初始state</span></span><br><span class="line">	<span class="keyword">let</span> initialState = &#123; counter &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建新的Redux store实例</span></span><br><span class="line">	<span class="keyword">const</span> store = createStore(rootReducer, initialState);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//把组件渲染成字符串</span></span><br><span class="line">	<span class="keyword">const</span> html = renderToString(</span><br><span class="line">		<span class="xml"><span class="tag">&lt;<span class="title">Provider</span> <span class="attribute">store</span>=<span class="value">&#123;store&#125;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">App</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">Provider</span>&gt;</span></span><br><span class="line">	)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从Redux store得到初始state</span></span><br><span class="line">	<span class="keyword">const</span> finalState = store.getState();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//把渲染后的页面发给客户端</span></span><br><span class="line">	res.send(renderFullPage(html, finalState));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-2_获取异步state">7.2 获取异步state</h4><p>服务端渲染常用的场景是处理异步state。因为服务端渲染是同步的，如何将异步的数据获取操作对应到同步操作呢？</p>
<p>最简单的做法就向同步代码里面传递一些回调函数。在这个回调函数里引用响应对象，把渲染后的HTML发给客户端。</p>
<h3 id="8_React-router服务端渲染">8 React-router服务端渲染</h3><p>react-router在服务端渲染与客户端有所不同，需要：</p>
<blockquote>
<ul>
<li><p>发送错误时发送一个500响应</p>
</li>
<li><p>需要重定向时发送一个30x响应</p>
</li>
<li><p>在渲染之前获得数据</p>
</li>
</ul>
</blockquote>
<p>为了满足这些需求，需要在<Router> API下一层使用：</p>
<blockquote>
<ul>
<li><p>使用match在渲染之前根据location匹配route</p>
</li>
<li><p>使用RoutingContext同步渲染route组件</p>
</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; match, RoutingContext &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</span><br><span class="line"><span class="keyword">import</span> routers <span class="keyword">from</span> <span class="string">'./routes'</span>;</span><br><span class="line"></span><br><span class="line">app.use( (req, res) =&gt; &#123;</span><br><span class="line">	match(&#123; routes, location: req.url &#125;, (error, redirectLocation, renderProps) =&gt; &#123;</span><br><span class="line">		<span class="keyword">if</span>(error) &#123;</span><br><span class="line">			res.send(<span class="number">500</span>, error.message);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(redirectLocation) &#123;</span><br><span class="line">			res.redirect(<span class="number">302</span>, redirectLocation.pathname + redirectLocation.search);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(renderProps) &#123;</span><br><span class="line">			res.send(<span class="number">200</span>, renderToString(</span><br><span class="line">				<span class="xml"><span class="tag">&lt;<span class="title">RoutingContext</span> &#123;<span class="attribute">...renderProps</span>&#125; /&gt;</span></span><br><span class="line">			)</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			res.send(<span class="number">404</span>, <span class="string">'Not Found'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</script></p></blockquote>
      
      

      <!-- page.path 表示不含根路径的页面网址。还有数种方式可以匹配页面，在此不赘述。 -->
        
    </div>
    
    <div class="article-info article-info-index">
      
      

      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React-router/">React-router</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redux/">Redux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/server-render/">server render</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/服务端渲染/">服务端渲染</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>










  
    <article id="post-Redux数据流" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/18/Redux数据流/" class="article-date">
  	<time datetime="2016-03-18T02:19:11.000Z" itemprop="datePublished">2016-03-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/18/Redux数据流/">Redux数据流</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>严格的单向数据流是Redux架构的设计核心。</p>
<p>应该中所有的数据都遵循相同的生命周期。</p>
<p>Redux应用中数据的生命周期遵循下面4个步骤：</p>
<h3 id="1_调用store-dispatch(action)">1 调用store.dispatch(action)</h3><p>action就是一个描述发生了什么的普通对象，如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">type</span>:<span class="value"> <span class="string">'update'</span>,</span><br><span class="line">	index: <span class="number">12</span></span><br><span class="line"></span></span></span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2_Redux_store调用传入的reducer函数">2 Redux store调用传入的reducer函数</h3><p>store会给reducer传入两个参数：当前的state树和action。</p>
<p>reducer是纯函数，仅仅用于计算下一个state，它的行为应该是完全可预测的：多次传入相同的输入必定产生相同的输出。</p>
<h3 id="3_根reducer应该把多个子reducer输出合并成一个单一的state树">3 根reducer应该把多个子reducer输出合并成一个单一的state树</h3><p>根reducer的结构完全由我们决定。Redux原生提供了combinerReducers()辅助函数，用来把各个子reducer合并成一个reducer，输出一个单一的state树。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todos</span><span class="params">(state = [], action)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">return</span> newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visibleTodoFilter</span><span class="params">(state = <span class="string">'SHOW_ALL'</span>, action)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">return</span> nextState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> todoApp = combineReducers(&#123;</span><br><span class="line">	todos,</span><br><span class="line">	visibleTodoFilter</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="4_Redux_store保存了根reducer返回的完整state树">4 Redux store保存了根reducer返回的完整state树</h3><p>返回的新的state树就是应用的下一个state。所有订阅store.subscribe(listener)的监听器都将被调用；在监听器里调用store.getState()获得当前state。</p>

      
      

      <!-- page.path 表示不含根路径的页面网址。还有数种方式可以匹配页面，在此不赘述。 -->
        
    </div>
    
    <div class="article-info article-info-index">
      
      

      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redux/">Redux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据流/">数据流</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>










  
    <article id="post-middleware演变过程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/18/middleware演变过程/" class="article-date">
  	<time datetime="2016-03-18T02:15:18.000Z" itemprop="datePublished">2016-03-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/18/middleware演变过程/">middleware演变过程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>通过记录日志来说明Middleware的演变过程。</p>
<blockquote>
<p>当应用中每一个action被发起以及每次新的state被计算完成时都将它们记录下来，如何通过Redux实现？</p>
</blockquote>
<h3 id="1_手动记录">1 手动记录</h3><p>最直接的方法是每次调用store.dispatch(action)前后手动记录被发起的action和state。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="function"><span class="title">dispatch</span><span class="params">(addTodo(<span class="string">'Redux'</span>)</span></span>)</span><br></pre></td></tr></table></figure>
<p>为了记录这个action及产生的新的state，可以通过以下方式记录日志。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let action = addTodo('Redux');</span><br><span class="line"></span><br><span class="line">console.<span class="keyword">log</span>('dispatching action:' , action);</span><br><span class="line">store.dispatch(action);</span><br><span class="line">console.<span class="keyword">log</span>('next <span class="keyword">state</span>:', store.getState());</span><br></pre></td></tr></table></figure>
<h3 id="2_封装Dispatch">2 封装Dispatch</h3><p>可以将上面的操作封装成一个函数。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> dispatchAndLog(store, <span class="keyword">action</span>) &#123;</span><br><span class="line">	console.<span class="built_in">log</span>(<span class="string">'dispatching action:'</span>, <span class="keyword">action</span>);</span><br><span class="line">	store.dispatch(<span class="keyword">action</span>);</span><br><span class="line">	console.<span class="built_in">log</span>(<span class="string">'next state:'</span>, store.getState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后用dispatchAndLog方法替换store.dispatch()。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatchAndLog<span class="list">(<span class="keyword">store</span>, addTodo<span class="list">(<span class="quoted">'Redux</span>')</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="3_Moneypatching_Dispatch">3 Moneypatching Dispatch</h3><p>如果我们直接替换store实例中dispatch函数会怎么样呢？</p>
<p>Redux store只是一个包含一些方法的普通对象，因此我们可以这样实现dispatch的monkeypatch。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> next = store.dispatch;</span><br><span class="line">store.dispatch = function dispatchAndLog(action) &#123;</span><br><span class="line">	console.log('dispatching action:', action);</span><br><span class="line">	<span class="keyword">let</span> <span class="literal">result</span> = next(action);</span><br><span class="line">	console.log('next state:', store.getState());</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，无论我们从哪里发起action，保证都会被记录。此时，如果我们想对dispatch附加超过一个的变换时会怎么样？如记录JS报错信息，而这和日志记录应该属于不同的模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchStoreAddLog</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> next = store.dispatch;</span><br><span class="line">	store.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatchAndLog</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'dispatching action:'</span>, action);</span><br><span class="line">		<span class="keyword">let</span> result = next(action);</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'next state:'</span>, store.getState());</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchStoreAddReporting</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> next = store.dispatch;</span><br><span class="line">	store.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatchAndReporting</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> next(action);</span><br><span class="line">		&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">			<span class="built_in">console</span>.error(<span class="string">'has a error:'</span>, err);</span><br><span class="line">			Raven.captureException(err, &#123;</span><br><span class="line">				extra: &#123;</span><br><span class="line">					action,</span><br><span class="line">					state: store.getState()</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			<span class="keyword">throw</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在store中就可以使用它们：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patchStoreAddLog<span class="list">(<span class="keyword">store</span>)</span><span class="comment">;</span></span><br><span class="line">patchStoreAddReporting<span class="list">(<span class="keyword">store</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="4_隐藏Moneypatching">4 隐藏Moneypatching</h3><p>Moneypatching本质上是一种hack：将任意的方法替换成我们需要的。我们使用自己的函数替换了store.dispatch，如果我们不这样做，而是在函数中返回新的dispatch，会怎么样呢？</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function logger(store) &#123;</span><br><span class="line">	<span class="keyword">let</span> next = store.dispatch;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> function dispatchAndLog(action) &#123;</span><br><span class="line">		console.log('dispatching action:', action);</span><br><span class="line">		<span class="keyword">let</span> <span class="literal">result</span> = next(action);</span><br><span class="line">		console.log('next state:', store.getState());</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在Redux内部提供一个可以将实际的monkeypatching应用到store.dispatch中的辅助方法。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddlewareByMonkeypatching</span><span class="params">(store, middlewares)</span> </span>&#123;</span><br><span class="line">	middlewares = middlewares.slice();</span><br><span class="line">	middlewares.reverse();</span><br><span class="line"></span><br><span class="line">	middlewares.<span class="keyword">forEach</span>(middleware =&gt;</span><br><span class="line">		store.dispatch = middleware(store)</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以应用多个middleware。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">applyMiddlewareByMonkeypatching</span><span class="params">(store, [logger, reporting])</span></span></span><br></pre></td></tr></table></figure>
<p>尽管我们做了很多，但实现方式依然是monkeypatching。</p>
<h3 id="5_移除Monkeypatching">5 移除Monkeypatching</h3><p>为什么要替换原来的dispatch呢？</p>
<blockquote>
<p>可以在后面直接调用它</p>
<p>每一个middleware都可以操作或直接调用前一个middleware包装过的store.dispatch</p>
</blockquote>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function logger(store) &#123;</span><br><span class="line">	//这里的next必须指向前一个middleware返回的函数</span><br><span class="line">	<span class="keyword">let</span> next = store.dispatch;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> function dispatchAndLog(action) &#123;</span><br><span class="line">		console.log('dispatching action:', action);</span><br><span class="line">		<span class="keyword">let</span> <span class="literal">result</span> = next(action);</span><br><span class="line">		console.log('next state:', store.getState());</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将middleware串起来是非常有必要的。如果applyMiddlewareByMonkeypatching方法中没有在第一个middleware执行时立即替换掉store.dispatch，那么store.dispatch将会一直指向原始的dispatch方法。即第二个middleware依旧会作用在原始的dispatch方法上。</p>
<p>还有另外一种实现这种链式调用的效果：让middleware以方法参数的形式接收一个next()方法，而不是通过store的实例去获取。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function logger(store) &#123;</span><br><span class="line">	<span class="keyword">return</span> function wrapDispatchAddLogge(next) &#123;</span><br><span class="line">		<span class="keyword">return</span> function dispatchAndLog(action) &#123;</span><br><span class="line">			console.log('dispatching action:', action);</span><br><span class="line">			<span class="keyword">let</span> <span class="literal">result</span> = next(action);</span><br><span class="line">			console.log('next state:', store.getState());</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用ES6的箭头函数使其柯里化。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> logger = store =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">	console.log('dispatching action:', action);</span><br><span class="line">	<span class="keyword">let</span> <span class="literal">result</span> = next(action);</span><br><span class="line">	console.log('next state:', store.getState());</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reporting = store =&gt; next =&gt; action =&gt; &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> next(action)</span><br><span class="line">	&#125; catch(err) &#123;</span><br><span class="line">		console.log('has a error:', err);</span><br><span class="line">		<span class="type">Raven</span>.captureException(err, &#123;</span><br><span class="line">			extra: &#123;</span><br><span class="line">				action,</span><br><span class="line">				state: store.getState()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">		throw err;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这正是Redux middleware的样子。</p>
<p>Middleware接收一个next()的dispatch函数，并返回一个dispatch函数，返回的函数被作为下一个middleware的next()，以此类推。由于store中类似getState()方法非常有用，因此我们将store作为顶层的参数，使得它可以在所有middleware中被使用。</p>
<h3 id="6_“单纯”地使用Middleware">6 “单纯”地使用Middleware</h3><p>写一个applyMiddleware()方法替换原来的applyMiddlewareByMonkeypatching()。在applyMiddleware()方法中，获取到完整的被包装过的dispatch()函数，并返回一个store的副本。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span><span class="params">(store, middlewares)</span> </span>&#123;</span><br><span class="line">	middlewares = middlewares.slice();</span><br><span class="line">	middlewares.reverse();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> dispatch = store.dispatch;</span><br><span class="line">	middlewares.<span class="keyword">forEach</span>( middleware =&gt;</span><br><span class="line">		dispatch = middleware(store)(dispatch)</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Object.assign(&#123;&#125;, store, &#123; dispatch &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码与Redux中applyMiddleware()的实现已经很接近了，但有三个重要的不同之处：</p>
<blockquote>
<ul>
<li><p>它只暴露一个store API的子集给middleware：dispatch(action)和getState()</p>
</li>
<li><p>它用了一个非常巧妙的方式来保证middleware调用的是store.dispatch(action)而不是next(action)，从而使这个action会在包括当前middleware在内的整个middleware链中被正确的传递。</p>
</li>
<li><p>为了保证只应用middleware一次，它作用在createStore()上而不是store本身。因此它的签名不是(store, middlewares) =&gt; store，而是(…middlewares) =&gt; (createStore) =&gt; createStore</p>
</li>
</ul>
</blockquote>

      
      

      <!-- page.path 表示不含根路径的页面网址。还有数种方式可以匹配页面，在此不赘述。 -->
        
    </div>
    
    <div class="article-info article-info-index">
      
      

      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Middleware/">Middleware</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redux/">Redux</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>










  
    <article id="post-翻译-React组件、元素和实例" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/29/翻译-React组件、元素和实例/" class="article-date">
  	<time datetime="2016-01-29T07:14:42.000Z" itemprop="datePublished">2016-01-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/29/翻译-React组件、元素和实例/">[翻译]React组件、元素和实例</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>组件、组件实例和元素之间的区别会让很多初学者感到困惑。为什么会有三种不同的术语来指代渲染到屏幕上的东西呢？</p>
<h3 id="管理实例">管理实例</h3><p>如果你是React初学者，你可能只会用到组件类和它的实例。例如，你可以通过创建一个类来声明一个Button组件。当应用程序运行的时候，可能会有这个组件的多个实例，每一个都有自己的属性和本地状态。这就是传统的面向对象的GUI编程，为什么要引入元素？</p>
<p>在这个传统的UI模型中，你需要关心子组件实例的创建和销毁。如果一个Form组件要渲染一个Button组件，需要创建它的实例，并且需要手动更新它的状态。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Form</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">TraditionalObjectOrientedView</span> &#123;</span></span><br><span class="line">	render() &#123;</span><br><span class="line">		const &#123; isSubmitted, buttonText &#125; = <span class="keyword">this</span>.attrs;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!isSubmitted &amp;&amp; !<span class="keyword">this</span>.button) &#123;</span><br><span class="line">			<span class="comment">//form还没有提交，创建Button实例</span></span><br><span class="line">			<span class="keyword">this</span>.button = <span class="keyword">new</span> <span class="type">Button</span>(&#123;</span><br><span class="line">				children: buttonText,</span><br><span class="line">				color: <span class="symbol">'blu</span>e'</span><br><span class="line">			&#125;);</span><br><span class="line">			<span class="keyword">this</span>.el.appendChild(<span class="keyword">this</span>.button.el);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.button) &#123;</span><br><span class="line">			<span class="comment">//button是可用的，更新文本信息</span></span><br><span class="line">			<span class="keyword">this</span>.button.attrs.children = buttonText;</span><br><span class="line">			<span class="keyword">this</span>.button.render();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(isSubmitted &amp;&amp; <span class="keyword">this</span>.button) &#123;</span><br><span class="line">			<span class="comment">//表单已提交，销毁button组件实例</span></span><br><span class="line">			<span class="keyword">this</span>.el.removeChild(<span class="keyword">this</span>.button.el);</span><br><span class="line">			<span class="keyword">this</span>.button.destory();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(isSubmmited &amp;&amp; !<span class="keyword">this</span>.message) &#123;</span><br><span class="line">			<span class="comment">//表单提交成功，显示提示信息</span></span><br><span class="line">			<span class="keyword">this</span>.message = <span class="keyword">new</span> <span class="type">Message</span>(&#123;text: <span class="symbol">'succes</span>s'&#125;);</span><br><span class="line">			<span class="keyword">this</span>.el.appendChild(<span class="keyword">this</span>.message.el);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是伪代码，当你使用比如Backbone这种传统的面向对象的库开发复合UI代码时，最终或多或少有这种体验。</p>
<p>每个组件实例都要保持对DOM节点和子组件实例的引用，在适合的时间创建，更新并销毁。</p>
<p>随着代码量的增加，组件可能的状态数会按平方级增长，并且父级可以直接访问子组件的实例，将来想要解偶就会变的非常困难。</p>
<p>那么，React有何不同呢？</p>
<h3 id="用元素来描述树形结构">用元素来描述树形结构</h3><p>在React里面，使用元素来解决这种问题。<strong>一个元素就是一个普通的对象，用来描述组件实例或DOM节点或它所需的属性</strong>。它只包括组件类型（如Button）、组件属性及组件的所有子元素的信息。</p>
<p>元素不是一个真实的实例。相反，它是告诉React在屏幕上展示哪些内容的一种方式。不能在元素上调用任何方法。它只是一个不可变的描述性的对象，拥有两个字段：type（string或ReactClass）和props（object）。</p>
<h4 id="DOM元素">DOM元素</h4><p>当一个元素的类型是字符串，它表示该标签名对应的DOM节点，props对应它的属性。这就是React怎么渲染的。如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">type</span>:<span class="value"> <span class="string">'button'</span>,</span><br><span class="line">	props: &#123;</span><br><span class="line">		className: <span class="string">'button button-blue'</span>,</span><br><span class="line">		children: &#123;</span><br><span class="line">			type: <span class="string">'b'</span>,</span><br><span class="line">			props: &#123;</span><br><span class="line">				children: <span class="string">'OK!'</span></span><br><span class="line">			</span></span></span>&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个也只是用普通对象表示下面HTML的一种方式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">button</span> <span class="attribute">class</span>=<span class="value">'button button-blue'</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">b</span>&gt;</span></span><br><span class="line">		OK!</span><br><span class="line">	<span class="tag">&lt;/<span class="title">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意元素如何嵌套。按照惯例，当我们想创建一个元素树的时候，我们指定一个或多个子元素，作为它们包含元素的子属性。</p>
<p>重要的是都是描述子元素和父元素，而不是真实的实例。当创建它们的时候不参考屏幕上面的任何东西。你可以创建它们，也可以丢弃掉，都不会有太大的影响。</p>
<p>React元素很容易遍历，不需要进行解析，相对于实际DOM元素它们很轻量，它们只是对象而已。</p>
<h4 id="组件元素">组件元素</h4><p>元素的类型可以是函数或对应于React组件的类。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">type</span>:<span class="value"> Button,</span><br><span class="line">	props: &#123;</span><br><span class="line">		color: <span class="string">'blue'</span>,</span><br><span class="line">		children: <span class="string">'OK!'</span></span><br><span class="line">	</span></span></span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是React的核心理念。</p>
<p><strong>描述组件的元素也是一个元素，就像描述DOM节点的元素。它们可以彼此嵌套和混合。</strong></p>
<p>这个特性可以让你使用具有特定的颜色属性值的Button定义一个DangerButton组件，而完全不用担心Button组件渲染到DOM中以后是button、div或别的其它什么东西。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const DangerButton = <span class="function"><span class="params">(&#123; children &#125;)</span> =&gt;</span> (&#123;</span><br><span class="line">	<span class="attribute">type</span>: Button,</span><br><span class="line">	<span class="attribute">props</span>: &#123;</span><br><span class="line">		<span class="attribute">color</span>: <span class="string">'red'</span>,</span><br><span class="line">		<span class="attribute">children</span>: children</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>一个元素树形结构中可以混合和匹配DOM元素和组件元素。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const DeleteAccount = () =&gt; (&#123;</span><br><span class="line">	type: <span class="string">'div'</span>,</span><br><span class="line">	props: &#123;</span><br><span class="line">		children: [&#123;</span><br><span class="line">			type: <span class="string">'p'</span>,</span><br><span class="line">			props: &#123;</span><br><span class="line">				children: <span class="string">'Are you sure?'</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			type: DangerButton,</span><br><span class="line">			props: &#123;</span><br><span class="line">				children: <span class="string">'Yep'</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			type: Button,</span><br><span class="line">			props: &#123;</span><br><span class="line">				color: <span class="string">'blue'</span>,</span><br><span class="line">				children: <span class="string">'Cancel'</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用JSX表示形式如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const DeleteAccount = () =&gt; (</span><br><span class="line">	<span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">p</span>&gt;</span>Are you sure?<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">DangerButton</span>&gt;</span>Yep<span class="tag">&lt;/<span class="title">DangerButton</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">Button</span> <span class="attribute">color</span>=<span class="value">'blue'</span>&gt;</span>Cancel<span class="tag">&lt;/<span class="title">Button</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这种混合和匹配有助于降低组件之间的耦合度，因此它们完全可以通过一下的结构同时表达is-a和has-a的关系：</p>
<blockquote>
<ul>
<li>Button组件是一个具有特定属性的DOM元素button；</li>
<li>DangerButton组件是一个具有特定属性的Button组件；</li>
<li>DeleteAccount在一个div元素中包含一个Button组件和一个DangerButton组件。</li>
</ul>
</blockquote>
<h3 id="组件封装元素树">组件封装元素树</h3><p>当React看到一个有function或class类型的元素时，它就会询问这个组件会渲染出什么元素，并提供了哪些对应的props。</p>
<p>当React看到下面这个元素时：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">type</span>:<span class="value"> Button,</span><br><span class="line">	props: &#123;</span><br><span class="line">		color: <span class="string">'blue'</span>,</span><br><span class="line">		children: <span class="string">'OK!'</span></span><br><span class="line">	</span></span></span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React将会问Button组件会渲染出什么，这个Button组件将会返回以下元素：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">type</span>:<span class="value"> <span class="string">'button'</span>,</span><br><span class="line">	props: &#123;</span><br><span class="line">		className: <span class="string">'button button-blue'</span>,</span><br><span class="line">		children: &#123;</span><br><span class="line">			type: <span class="string">'b'</span>,</span><br><span class="line">			props: &#123;</span><br><span class="line">				children: <span class="string">'OK!'</span></span><br><span class="line">			</span></span></span>&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React将会重复这个过程，直到页面上所有的组件都被替换为底层DOM标签元素为止。</p>
<p>React就像一个小孩，每遇到一个“X is Y”就会问“什么是Y”，你就需要给他解释，直到他弄清楚了所有的事情。</p>
<p>还记得上面的Form栗子吗？使用React可以写成如下形式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const <span class="type">Form</span> = (&#123; isSubmmited buttonText &#125;) =&gt; &#123;</span><br><span class="line">	<span class="keyword">if</span>(isSubmitted) &#123;</span><br><span class="line">		<span class="comment">//Form已经提交，返回一个message元素</span></span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="class"><span class="keyword">type</span>:</span> <span class="type">Message</span>,</span><br><span class="line">			props: &#123;</span><br><span class="line">				text: <span class="symbol">'Success</span>!'</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//form仍然可用，返回一个button元素</span></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">type</span>:</span> <span class="type">Button</span>,</span><br><span class="line">		props: &#123;</span><br><span class="line">			children: buttonText,</span><br><span class="line">			color: <span class="symbol">'blu</span>e'</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>经此而已！对于一个React组件，props是输入，输出是元素树。</p>
<p><strong>返回的元素树包括描述DOM节点的元素及描述其它组件的元素。这可以让我们独立地编写UI部分，而无需依赖它们的内部DOM结构。</strong></p>
<p>我们可以创建、更新和销毁React实例。我们使用返回的组件元素描述它们，React只关心实例的管理。</p>
<h3 id="组件可以是Classes或Functions">组件可以是Classes或Functions</h3><p>在上面的代码中，Form、Message和Button都是React组件。它们既可以使用函数方式来写，就像上面的代码，也可以使用继承了React.Component的classes。以下三种声明组件的方式大都是等价的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 作为props的函数</span></span><br><span class="line">const <span class="type">Button</span> = (&#123; children, color &#125;) =&gt; (&#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span>:</span> <span class="symbol">'butto</span>n',</span><br><span class="line">	props: &#123;</span><br><span class="line">		className: <span class="symbol">'button</span> button-' + color,</span><br><span class="line">		children: &#123;</span><br><span class="line">			<span class="class"><span class="keyword">type</span>:</span> 'b',</span><br><span class="line">			props: &#123;</span><br><span class="line">				children: children</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 使用React.createClass()工厂方法</span></span><br><span class="line">const <span class="type">Button</span> = <span class="type">React</span>.createClass(&#123;</span><br><span class="line">	render: function() &#123;</span><br><span class="line">		const &#123; children, color &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="class"><span class="keyword">type</span>:</span> <span class="symbol">'butto</span>n',</span><br><span class="line">			props: &#123;</span><br><span class="line">				className: <span class="symbol">'button</span> button-' + color,</span><br><span class="line">				children: &#123;</span><br><span class="line">					<span class="class"><span class="keyword">type</span>:</span> 'b',</span><br><span class="line">					props: &#123;</span><br><span class="line">						children: children</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 使用继承了React.Component的ES6类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	render() &#123;</span><br><span class="line">		const &#123; children, color &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="class"><span class="keyword">type</span>:</span> <span class="symbol">'butto</span>n',</span><br><span class="line">			props: &#123;</span><br><span class="line">				className: <span class="symbol">'button</span> button-' + color,</span><br><span class="line">				children: &#123;</span><br><span class="line">					<span class="class"><span class="keyword">type</span>:</span> 'b',</span><br><span class="line">					props: &#123;</span><br><span class="line">						children: children</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个组件使用class来定义时，它的功能比使用function定义的组件要强大一点。当对应的DOM节点被创建或销毁时它可以存储一些局部变量并执行自定义逻辑。</p>
<p>函数组件功能没有那么强大，但它比较简单，类似于只有一个单一的render()方法的类组件。除非在class中需要提供其它的功能，否则推荐使用函数组件。</p>
<p><strong>然而，无论是函数组件或类组件，本质上都是React组件。它们把props作为其输入，并返回元素作为它们的输出。</strong></p>
<h3 id="自上而下的协同">自上而下的协同</h3><p>当你调用如下代码：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">ReactDOM</span><span class="class">.render</span>(&#123;</span><br><span class="line">	<span class="tag">type</span>: <span class="tag">Form</span>,</span><br><span class="line">	<span class="tag">props</span>: &#123;</span><br><span class="line">		<span class="attribute">isSubmitted</span>: false,</span><br><span class="line">		<span class="attribute">buttonText</span>: <span class="string">'OK!'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;, document.<span class="function">getElementById</span>(<span class="string">'container'</span>));</span><br></pre></td></tr></table></figure>
<p>React会问这个Form组件返回什么样的元素树及其提高的props。React将会根据在简单的原语层面对React组件的理解来逐步完善它。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//React: You told me this...</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span>:</span> <span class="type">Form</span>,</span><br><span class="line">	props: &#123;</span><br><span class="line">		isSubmitted: <span class="literal">false</span>,</span><br><span class="line">		buttonText: <span class="symbol">'OK</span>!'</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//React: Form提供的信息</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span>:</span> <span class="type">Button</span>,</span><br><span class="line">	props: &#123;</span><br><span class="line">		children: <span class="symbol">'OK</span>!',</span><br><span class="line">		color: <span class="symbol">'blu</span>e'</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//React: Button提供的信息</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span>:</span> <span class="symbol">'butto</span>n',</span><br><span class="line">	props: &#123;</span><br><span class="line">		className: <span class="symbol">'button</span> button-blue',</span><br><span class="line">		children: &#123;</span><br><span class="line">			<span class="class"><span class="keyword">type</span>:</span> 'b',</span><br><span class="line">			props: &#123;</span><br><span class="line">				children: <span class="symbol">'OK</span>!'</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用ReactDOM.render()或setState()时，这就是被React成为协同的过程。协同的过程结束以后，React已经知道了DOM树的结果，react-dom或react-native根据需要更新的DOM节点进行一次最小的渲染。</p>
<p>这种渐进精炼的过程也是React应用很容易优化的原因。如果组件树的一部分变的太大而不能高效的访问，如果想过的props并没有改变时，你可以告诉React跳过这个“refining”和比较组件树的某些部分的过程。如果它们是不可变的，则计算props是否改变了就会非常快，因此React和不可变的数据能够很好的工作，并且很小的工作量就可以起到极大的优化作用。</p>
<p>你可能已经注意到了，这篇博客谈了很多有关组件和元素的内容，并没有过多的谈论实例。事实就是，在React中，实例并没有在大多数面对对象的UI框架中那么重要。</p>
<p>仅仅使用class来声明组件，就会有实例，从来不需要直接创建它们：React已经替我们创建了实例。存在一个父组件实例访问子组件实例的机制，它们仅被用于一些不得已的操作（如设置字段焦点），通常应该避免这样的操作。</p>
<p>React需要为每一个class组件创建实例，因此你可以使用面对对象的方式，使用方法和局部变量来开发组件，但除此之外，实例在React编程模式中不是很重要，并且都是React自身来管理实例的。</p>
<h3 id="总结">总结</h3><p>元素就是普通的对象，用来描述呈现在屏幕上的DOM节点或其它组件。元素的props中可以包含其它元素。创建React元素是廉价的，一旦创建了React元素，就不会再发生变化。</p>
<p>一个组件可以使用几种不同的方式来声明。它可以是一个有render()方法的类。同样地，在一些简单的情况下，它可以被定义为函数。在这两种情况下，它把props作为输入，返回的元素树作为输出。</p>
<p>当一个组件接收到一些props作为输入，这是因为特定的父组件返回了一个具有类型和props的元素。这也就是为什么人们常说的props在React中是单向流动的：从父组件到子组件。</p>
<p>实例就是对组件类中this的引用。</p>
<p>函数组件根本就没有实例。类组件有实例，但永远不需要直接创建组件实例，React会完成这个实例的创建。</p>
<p>最后，要创建元素，可以使用React.createClass()，JSX或元素工厂助手。在真实开发时候不要使用普通对象来创建元素，只需要知道在引擎底层它们是普通对象即可。</p>

      
      

      <!-- page.path 表示不含根路径的页面网址。还有数种方式可以匹配页面，在此不赘述。 -->
        
    </div>
    
    <div class="article-info article-info-index">
      
      

      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Element/">Element</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/实例/">实例</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/组件/">组件</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>










  
    <article id="post-翻译-A-B-B-A" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/28/翻译-A-B-B-A/" class="article-date">
  	<time datetime="2016-01-28T09:24:11.000Z" itemprop="datePublished">2016-01-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/28/翻译-A-B-B-A/">[翻译](A =&gt; B) !=&gt; (B =&gt; A)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>componentWillReceiveProps的文档中指出：当props改变的时候，componentWillReceiveProps就会被调用，结果就会重新渲染。因此，一些人误以为：如果componentWillReceiveProps被调用，则props一定发生了变化。但是，这样的结论是不正确的。</p>
<p>我最喜欢的形式逻辑或数学的指导原则如下：</p>
<blockquote>
<p>A implies B does not imply B implies A</p>
</blockquote>
<p>举个栗子：“如果我吃了坏了的食物，我可能就会生病”并不能说“如果我生病了，那我就一定是吃了坏了的食物导致”。还有很多其它原因导致我不舒服的，比如办公室里的流感。类似的，有很多原因使得componentWillReceiveProps被调用，即使props并没有改变。</p>
<p>如果你不相信我说的，使用相同的props调用ReactDOM.render()三次，试着预测一下componentWillReceiveProps被调用的次数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">		console.log(<span class="symbol">'componentWillReceiveProps</span>: ' + nextProps.data.bar);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="keyword">return</span> &lt;div&gt;<span class="type">Bar</span> &#123;<span class="keyword">this</span>.props.data.bar&#125;&lt;/div&gt;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> container = document.getElementById(<span class="symbol">'containe</span>r');</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myData = &#123;</span><br><span class="line">	bar: <span class="symbol">'drink</span>s'</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">ReactDOM</span>.render(&lt;<span class="type">Component</span> data=&#123;myData&#125; /&gt;, container);</span><br><span class="line"><span class="type">ReactDOM</span>.render(&lt;<span class="type">Component</span> data=&#123;myData&#125; /&gt;, container);</span><br><span class="line"><span class="type">ReactDOM</span>.render(&lt;<span class="type">Component</span> data=&#123;myData&#125; /&gt;, container);</span><br></pre></td></tr></table></figure>
<p>在本例中，答案是“2”。React调用componentWillReceiveProps两次（只有两次更新）。在这两次中，drinks的值被打印出来（props的值并没有变化）。</p>
<p>为了理解为什么会这样，我们需要想想会发生什么。在初始渲染和两次后续更新之间数据可能已经被改变了，如果代码像下面这样执行：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">var</span> myData = &#123;</span><br><span class="line">	bar: 'drinks'</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ReactDOM</span>.render(&lt;<span class="type">Component</span> <span class="typedef"><span class="keyword">data</span>=<span class="container">&#123;<span class="title">myData</span>&#125;</span> /&gt;, container);</span></span><br><span class="line"></span><br><span class="line"><span class="title">myData</span>.bar = 'food';</span><br><span class="line"><span class="type">ReactDOM</span>.render(&lt;<span class="type">Component</span> <span class="typedef"><span class="keyword">data</span>=<span class="container">&#123;<span class="title">myData</span>&#125;</span> /&gt;, container);</span></span><br><span class="line"></span><br><span class="line"><span class="title">myData</span>.bar = 'noise';</span><br><span class="line"><span class="type">ReactDOM</span>.render(&lt;<span class="type">Component</span> <span class="typedef"><span class="keyword">data</span>=<span class="container">&#123;<span class="title">myData</span>&#125;</span> /&gt;, container);</span></span><br></pre></td></tr></table></figure>
<p>数据没有改变，但React并没有办法知道。因此，React需要调用componentWillReceiveProps方法，因为组件需要新props来通知（即使新的props和旧props完全相同）。</p>
<p>你可能会认为，React可以使用很巧妙的检测机制来检测是否相等，但这种想法也有一些问题：</p>
<blockquote>
<ul>
<li><p>旧的myData和新的myData实际上是相同的物理对象（仅对象内部的值被改变）。由于采用的是triple-equals-equal，检查是否相同的时候并不会告诉我们值是否被改变。惟一可能的解决方法就是创建数据的一个深拷贝副本，接着做深比较，但这对比较大的数据结构而言过于昂贵（特别是循环）</p>
</li>
<li><p>myData对象可能包括对函数的引用，该函数通过闭包获取变量。React没有办法获取闭包内部的变量值，因此也没有办法复制和验证它们是否相等</p>
</li>
<li><p>myData可能包括父级渲染时重新实例化了的实例对象的引用，但概念上是相等的（具有相同的key和value）。深比较可以检测到这一点，除过这点又会出现新的问题，因为没有办法比较两个函数在语义上是否相同。</p>
</li>
</ul>
</blockquote>
<p>由于语言的限制，有时我们不可能实现真正意义上相等的语义。在这种情况下，React会调用componentWillReceiveProps方法（即使props可能没有改变），使得组件有机会检测新的props，并采取相应的处理。</p>
<p>这样一来，实现componentWillReceiveProps方法时候要确保props不能被修改。如果你想在props被改变后执行一些操作（如网络请求），你的componentWillReceiveProps代码需要检查props是否真正的被改变了。</p>

      
      

      <!-- page.path 表示不含根路径的页面网址。还有数种方式可以匹配页面，在此不赘述。 -->
        
    </div>
    
    <div class="article-info article-info-index">
      
      

      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/componentWillReceiveProps/">componentWillReceiveProps</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>










  
    <article id="post-翻译-React组件API" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/28/翻译-React组件API/" class="article-date">
  	<time datetime="2016-01-28T06:47:43.000Z" itemprop="datePublished">2016-01-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/28/翻译-React组件API/">[翻译]React组件API</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="React-Component">React.Component</h3><p>当渲染的时候在React内部创建一个React组件的实例，这些实例在随后的渲染中都是可以被重复使用的，并且可以在组件的方法中作为this被访问。这是唯一可以处理在React外部的React组件中存储ReactDom.render的返回值的方式，其它组件内部，则可以使用refs的到相同的结果。</p>
<h3 id="setState">setState</h3><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> setState(</span><br><span class="line">	<span class="keyword">function</span> | <span class="keyword">object</span> nextState,</span><br><span class="line">	[<span class="keyword">function</span> callback]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>对nextState执行浅合并到当前state，该方法是用于处理事件处理程序和服务请求回调触发UI更新的主要方法。</p>
<p>第一个参数可以是对象（含0个或多个待更新的key）或返回一个包含了更新后的所有key的函数（state和props）。</p>
<p>简单的对象参数示例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">setState</span>(<span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">myName</span>:<span class="value"> <span class="string">'name'</span></span><br><span class="line"></span></span></span>&#125;);</span><br></pre></td></tr></table></figure>
<p>设置任何values之前，当我们想参考以前的state和props的值来进行原子更新时候可以通过一个签名function(state, props)来实现。比如我们想增加一个状态值。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">setState</span>(<span class="function">function</span>(previousState, currentProps) &#123;</span><br><span class="line">	<span class="tag">return</span> &#123;</span><br><span class="line">		<span class="attribute">myNum</span>: previousState.num + <span class="number">1</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>第二个参数是当setState执行成功一次并且组件被重新渲染时候的一个回调函数。</p>
<blockquote>
<p>不要直接修改this.state的值，通过调用setState来更新state的值。应该将this.state视为不可变的。</p>
<p>setState()不会立即修改this.state，而是新增一个过渡的挂起状态。调用setState()方法后访问this.state时，可以潜在的返回一个现有的值。</p>
<p>不能保证调用setState()是同步进行的，为了提升性能，调用setState可能是分批进行的。</p>
<p>setState()总会触发重现渲染，除非渲染逻辑是在shouldComponentUpdate()中实现。如果正在使用可变的对象，并且渲染逻辑没有在shouldComponentUpdate()中实现，调用setState()，只有当新的state和前一个state不同才渲染，从而避免了不必要的渲染。</p>
</blockquote>
<h3 id="replaceState">replaceState</h3><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> replaceState(</span><br><span class="line">	<span class="keyword">object</span> nextState,</span><br><span class="line">	[<span class="keyword">function</span> callback]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>类似setState()方法，不同的是删除了不在nextState中的所有预先存在的state。</p>
<blockquote>
<p>该方法不适用于ES6类组件扩展React.Component,在以后的版本中可能会被删除。</p>
</blockquote>
<h3 id="forceUpdate">forceUpdate</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forceUpdate</span><span class="params">(</span><br><span class="line">	[function callback]</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>默认情况下，当组件的state或props改变的时候，组件就会重新渲染。但是，如果这些变化很含蓄（对象内部嵌套很深的数据改变，对象本身并不改变）或render()方法依赖其它数据时候，我们可以告诉React需要通过forceUpdate()方法重新渲染。</p>
<p>调用forceUpdate()方法会引起组件重新渲染，会跳过shouldComponentUpdate()方法。这将触发子组件的正常的生命周期方法，包括每个子组件的shouldComponentUpdate()方法。React仍然只更新DOM标记了改变的部分。</p>
<p>通常情况下应该避免使用forceUpdate()方法，在render()方法中只从this.props和this.state获取数据。这样可以确保组件的“纯”，应用程序也会更简单，更高效。</p>
<h3 id="getDOMNode">getDOMNode</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMElement <span class="function"><span class="title">getDOMNode</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>如果组件已经被装载到DOM中，该方法将会返回相应的原生浏览器的DOM元素。这个方法用来读取DOM的值，比如表单字段值，并进行DOM测试。当render返回null或false时，this.getDOMNode()返回null。</p>
<blockquote>
<p>getDOMNode()方法已被弃用，已替换为ReactDOM.findDomNode()。</p>
<p>该方法不适用于ES6类组件扩展React.Component，可能会在后续版本中删除。</p>
</blockquote>
<h3 id="isMounted">isMounted</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean <span class="function"><span class="title">isMounted</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>如果组件被渲染到DOM中，isMounted()返回true，否则返回false。可以使用此方法来保证对setState()或forceUpdate()的异步调用。</p>
<blockquote>
<p>该方法不适用于继承React.Component的ES6 class组件，可能会在后续版本中删除。</p>
</blockquote>
<h3 id="setProps">setProps</h3><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> setProps(</span><br><span class="line">	<span class="keyword">object</span> nextProps,</span><br><span class="line">	[<span class="keyword">function</span> callback]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>当与外部JavaScript应用程序继承时，可能需要一个信号的改变来使用ReactDOM.render()渲染一个React组件。</p>
<p>在根级组件中调用setProps()方法将会改变其属性，并触发重新渲染。此外，也可以在setProps()只执行一次和组件重新渲染完成后提供一个回调函数。</p>
<blockquote>
<p>该方法已被弃用，并将很快被删除。该方法不适用于ES6类组件扩展React.Component。通过使用新的props再次调用ReactDOM.render()来代替setProps()方法。其它注意事项，可参考<a href="http://baizn.github.io/2016/01/26/React%E9%A1%B6%E5%B1%82API/">React Top Level API</a>。</p>
<p>如果可能的话，在同一个节点上再次调用ReactDOM.render()反而是更可取的方式。这往往使更新更容易推理（这两种方法之间并没有显著的性能差异）。</p>
<p>该方法只能在根级组件调用，即它是唯一可以直接将组件传递到ReactDOM.render()的方法，并不包括其子组件。如果你倾向于在子组件上使用setProps()，应该改为当子组件创建时在其render()中使用更灵活的更新和传递新的props到子组件。</p>
</blockquote>
<h3 id="replaceProps">replaceProps</h3><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> replaceProps(</span><br><span class="line">	<span class="keyword">object</span> nextProps,</span><br><span class="line">	[<span class="keyword">function</span> callback]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>类似setProps()，但删除了预定存在的props，而不是合并两个对象。</p>
<blockquote>
<p>该方法已被弃用，并将很快被删除。</p>
<p>该方法不适用于继承React.Component的ES6 class组件。通过使用新的props再次调用ReactDOM.render()来代替replaceProps。</p>
</blockquote>

      
      

      <!-- page.path 表示不含根路径的页面网址。还有数种方式可以匹配页面，在此不赘述。 -->
        
    </div>
    
    <div class="article-info article-info-index">
      
      

      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/API/">API</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Component/">Component</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React组件/">React组件</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>










  
    <article id="post-翻译-React组件状态及生命周期" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/28/翻译-React组件状态及生命周期/" class="article-date">
  	<time datetime="2016-01-28T06:46:33.000Z" itemprop="datePublished">2016-01-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/28/翻译-React组件状态及生命周期/">[翻译]React组件状态及生命周期</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="组件规范">组件规范</h2><p>当调用React.createClass()方法创建组件的时候，我们应该提供一个包含了render方法的规范的对象，并且可以包含其它生命周期方法的描述。</p>
<blockquote>
<p>另外，也可以使用普通的JS类来定义组件。这些类可以实现大多数相同的方法，但也有一些差异。有关这些差异的详细信息，请参考<a href="http://baizn.github.io/2016/01/14/%E4%BD%BF%E7%94%A8ES6%E5%BC%80%E5%8F%91React/">ES6类的文档</a>。</p>
</blockquote>
<h3 id="render">render</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactElement <span class="function"><span class="title">render</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>render()方法是必须的。</p>
<p>当调用的时候，会检测this.props和this.state，返回一个单子级组件。改子级组件可以是虚拟的本地DOM组件（如\<div>或React.DOM.div()），也可以是自定义的复合组件。</div></p>
<p>也可以返回null或false来表明不需要渲染任何东西。实际上，React通过渲染一个\<noscript>标签来处理当前的差异检测逻辑。当返回null或false的时候，React.findDOMNode(this)将返回null。</noscript></p>
<p>render()函数应该是纯函数，即该函数不修改组件的state，每次调用都返回相同的结果，不读写DOM信息，也不和浏览器交互（如通过使用setTimeout）。如果需要和浏览器交互，在componentDidMount()方法中或其它生命周期方法中来做。保持render()函数为纯函数，可以使得服务端渲染更加切实可行，也使得组件更容易被理解。</p>
<h3 id="getInitialState">getInitialState</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">object</span> <span class="function"><span class="title">getInitialState</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>在组件挂载之前调用一次。返回值将会作为this.state的初始值。</p>
<h3 id="getDefaultProps">getDefaultProps</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">object</span> <span class="function"><span class="title">getDefaultProps</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>在组件类创建的时候调用一次，然后返回值被缓存下来。如果父组件没有指定props中的某个健，则此处返回的对象中的相应属性会合并到this.props（使用in检测属性）。</p>
<p>该方法在任何实例创建之前调用，因此不能依赖于this.props。另外，getDefaultProps()返回的任何复杂对象将会在实例间共享，而不是每个实例拥有一份拷贝。</p>
<h3 id="propTypes">propTypes</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">object</span> propTypes</span><br></pre></td></tr></table></figure>
<p>propTypes对象允许验证传入到组件的props。更多关于propTypes的信息，参考<a href="http://baizn.github.io/2016/01/27/React%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%BB%84%E4%BB%B6/">React可复用组件</a> 。</p>
<h3 id="mixins">mixins</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span> mixins</span><br></pre></td></tr></table></figure>
<p>mixin数组允许使用混合来在多个组件之间共享行为。更多关于mixin的信息，参考<a href="http://baizn.github.io/2016/01/27/React%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%BB%84%E4%BB%B6/">React可复用组件</a> 。</p>
<h3 id="statics">statics</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">object</span> statics</span><br></pre></td></tr></table></figure>
<p>statics对象允许定义静态方法，这些静态方法可以在组件类上调用。如：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloReact = React.createClass(&#123;</span><br><span class="line">	statics: &#123;</span><br><span class="line">		customMethod: <span class="function"><span class="keyword">function</span><span class="params">(foo)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> foo === <span class="string">'bar'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">HelloReact.customMethod(<span class="string">'bar'</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>在这个块里面定义的方法都试静态的，意味着你可以在任何组件实例创建之前调用它们，这些方法不能获取组件的props和state。如果想在静态方法中检测props的值，在调用处把props作为参数传入到静态方法。</p>
<h3 id="displayName">displayName</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> displayName</span><br></pre></td></tr></table></figure>
<p>displayName字符串用于输出调试信息，JSX自动设置该值。</p>
<h2 id="生命周期方法">生命周期方法</h2><p>许多方法在组件生命周期中某个确定的时间点执行。</p>
<h3 id="挂载(Mounting)：componentWillMount">挂载(Mounting)：componentWillMount</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">componentWillMount</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>服务端和客户端都只调用一次，在初始化渲染执行之前立即调用。如果在这个方法内调用setState，render()将会感知到更新后的state，将会执行一次，尽管state改变了。</p>
<h3 id="挂载(Mounting)：componentDidMount">挂载(Mounting)：componentDidMount</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">componentDidMount</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>在初始化渲染执行之后立即调用一次，仅客户端有效（服务端不会调用）。在生命周期的这个时间点上，可以访问子组件的任何refs（如访问底层DOM）。子组件的componentDidMount()方法在父组件之前调用。</p>
<p>如果想和其它JS框架集成，使用setTimeout或setInterval来设置定时器，或发送AJAX请求，可以在该方法中执行这些操作。</p>
<h3 id="更新(Updating)：componentWillReceiveProps">更新(Updating)：componentWillReceiveProps</h3><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> componentWillReceiveProps(</span><br><span class="line">	<span class="keyword">object</span> nextProps</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在组件接收到新的props时候调用。在初始化渲染时候，该方法不会被调用。</p>
<p>用此函数可以作为React在prop传入之后，render()方法被调用之前更新state的机会。老得props可以通过this.props获取到。在该函数中调用this.setState()将不会引起第二次渲染。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">componentWillReceiveProps</span>: <span class="tag">function</span>(nextProps) &#123;</span><br><span class="line">	<span class="tag">this</span><span class="class">.setState</span>(&#123;</span><br><span class="line">		<span class="attribute">likesIncreasing</span>: nextProps.likeCount &gt; this.props.likeCount</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个常见的错误是生命周期方法在执行过程中假设props被改变了。要理解这样为什么是无效的，请参考<a href="http://baizn.github.io/2016/01/28/%E7%BF%BB%E8%AF%91-A-B-B-A/">A implies B does not imply B implies A</a>。</p>
<p>没有类似的componentWillReceiveState方法。传入的prop可能会导致state改变，反之则不然。如果需要在state改变的时候执行一些操作，请使用componentWillUpdate。</p>
</blockquote>
<h3 id="更新(Updating)：shouleComponentUpdate">更新(Updating)：shouleComponentUpdate</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean shouldComponentUpdate(</span><br><span class="line">	<span class="tag">object</span> nextProps, <span class="tag">object</span> nextState</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在接收到新的props或state，将要渲染之前调用。该方法在初始化渲染的时候不会调用，在使用forceUpdate方法时候也不会被调用。</p>
<p>如果确定新的props或state不会导致组件更新，则此处应该返回false。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate: <span class="function"><span class="keyword">function</span><span class="params">(nextProps, nextState)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> nextProps.id !== <span class="keyword">this</span>.props.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果shouldComponentUpdate返回false，则render()将不会执行，直到下一次state改变。另外，componentWillUpdate和componentDidUpdate也不会被调用。</p>
<p>默认情况下，shouldComponentUpdate总会返回true，在state改变的时候可以避免一些细微的BUG，但如果总是小心地把state当做不可变的，在render()中只从props和state读取值，此时可以覆盖shouldComponentUpdate方法，实现新旧props和state的比对逻辑。</p>
<p>如果性能是个瓶颈，尤其是有几十个甚至上百个组件的时候，使用shouldComponentUpdate可以提升应用的性能。</p>
<h3 id="更新(Updating)：componentWillUpdate">更新(Updating)：componentWillUpdate</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillUpdate(</span><br><span class="line">	<span class="tag">object</span> nextProps, <span class="tag">object</span> nextState</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在接收到新的props或state之前立即调用，在初始化渲染的时候该方法不会被调用。</p>
<p>使用该方法做一些更新之前的准备工作。</p>
<blockquote>
<p>在该方法中不能使用this.setState()。如果需要更新state来响应某个prop的改变，请使用componentWillReceiveProps方法。</p>
</blockquote>
<h3 id="更新(Updating)：componentDidUpdate">更新(Updating)：componentDidUpdate</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void componentDidUpdate(</span><br><span class="line">	<span class="tag">object</span> prevProps, <span class="tag">object</span> prevState</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在组件的更新已经同步到DOM中之后立即被调用，该方法不会在初始化渲染的时候调用。</p>
<p>使用该方法可以在组件更新后操作DOM元素。</p>
<h3 id="卸载(Unmounting)：componentWillUnmount">卸载(Unmounting)：componentWillUnmount</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">componentWillUnmount</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>组件从DOM中卸载之前立即被调用。</p>
<p>可以在该方法中执行任何必须的清理工作，如清除定时器或清除在componentDidMount中创建的任何DOM元素。</p>

      
      

      <!-- page.path 表示不含根路径的页面网址。还有数种方式可以匹配页面，在此不赘述。 -->
        
    </div>
    
    <div class="article-info article-info-index">
      
      

      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Props/">Props</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/state/">state</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/状态/">状态</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/生命周期/">生命周期</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>










  
    <article id="post-翻译-React可复用组件" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/28/翻译-React可复用组件/" class="article-date">
  	<time datetime="2016-01-28T06:45:28.000Z" itemprop="datePublished">2016-01-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/28/翻译-React可复用组件/">[翻译]React可复用组件</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>设计接口的时候，把常用的设计元素（如按钮，表单，布局组件等）拆成接口良好的定义的可复用的组件。这样，下次开发相同界面时就可以写更少的代码，也意味着更高的开发效率，更少的BUG和更少的程序体积。</p>
<h3 id="Prop验证">Prop验证</h3><p>随着应用的不断变大，保证组件被正确使用变的非常有用。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">React.createClass(&#123;</span><br><span class="line">	propTypes: &#123;</span><br><span class="line">		<span class="comment">//可以声明prop为指定的JS基本类型，默认情况下，这些prop都是可选的</span></span><br><span class="line">		optionalArray: React.PropTypes.<span class="keyword">array</span>,</span><br><span class="line">		optionalBool: React.PropTypes.<span class="keyword">bool</span>,</span><br><span class="line">		optionalFunc: React.PropTypes.func,</span><br><span class="line">		optionalNumber: React.PropTypes.number,</span><br><span class="line">		optionalObject: React.PropTypes.object,</span><br><span class="line">		optionalString: React.PropTypes.string,</span><br><span class="line"></span><br><span class="line">		<span class="comment">//所有类型都可以被渲染，numbers，string，elements或包括这些类型的数组</span></span><br><span class="line">		optionalNode: React.PropTypes.node,</span><br><span class="line"></span><br><span class="line">		<span class="comment">//react element</span></span><br><span class="line">		optionalElement: React.PropTypes.element,</span><br><span class="line"></span><br><span class="line">		<span class="comment">//使用JS的instanceof操作符，可以声明一个class实例的prop</span></span><br><span class="line">		optionalMessage: React.PropTypes.<span class="keyword">instanceOf</span>(Message),</span><br><span class="line"></span><br><span class="line">		<span class="comment">//可以限制props的值只在一个枚举中取值</span></span><br><span class="line">		optionalEnum: React.PropTypes.oneOf([<span class="string">'bbb'</span>, <span class="string">'aaa'</span>]),</span><br><span class="line"></span><br><span class="line">		<span class="comment">//指定多个对象类型中的一个</span></span><br><span class="line">		optionalUnion: React.PropTypes.oneOfType([</span><br><span class="line">			React.PropTypes.string,</span><br><span class="line">			React.PropTypes.number,</span><br><span class="line">			React.PropTypes.<span class="keyword">instanceOf</span>(Message)</span><br><span class="line">		]),</span><br><span class="line"></span><br><span class="line">		<span class="comment">//指定类型的属性构成的对象</span></span><br><span class="line">		optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),</span><br><span class="line"></span><br><span class="line">		<span class="comment">//特定对象参数</span></span><br><span class="line">		optionalObjectWithShape: React.PropTypes.shape(&#123;</span><br><span class="line">			color: React.PropTypes.string,</span><br><span class="line">			fontSize: React.PropTypes.number</span><br><span class="line">		&#125;),</span><br><span class="line"></span><br><span class="line">		<span class="comment">//为任意类型添加isRequired时，保证其props不为空</span></span><br><span class="line">		requiredFunc: React.PropTypes.func.isRequired,</span><br><span class="line"></span><br><span class="line">		<span class="comment">//非空的任意数据类型</span></span><br><span class="line">		requiredAny: React.PropTypes.any.isRequired,</span><br><span class="line"></span><br><span class="line">		<span class="comment">//自定义的验证器，如果验证失败则返回一个Error对象，不要使用console.warn或抛异常，因为会导致oneOfType失效</span></span><br><span class="line">		customProp: <span class="function"><span class="keyword">function</span><span class="params">(props, propName, componentName)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(!/matchme/.test(props[propName])) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> Error(<span class="string">'Validation failed!'</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Signle_Child">Signle Child</h3><p>使用React.PropTypes.element，你只能指定一个子元素作为children传递给组件。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloReact = React.createClass(&#123;</span><br><span class="line">	propTypes: &#123;</span><br><span class="line">		children: React.PropTypes.element.isRequired</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;div&gt;</span><br><span class="line">				&#123;<span class="comment">/*必选是一个元素，否则会出现警告*/</span>&#125;</span><br><span class="line">				&#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="默认Props值">默认Props值</h3><p>React支持以声明的方式来定义props的默认值。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentWithDefaultProps = React.createClass(&#123;</span><br><span class="line">	getDefaultProps: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			value: <span class="string">'default value'</span></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当父级没有传入props时，getDefaultProps()可以保证this.props.value有默认值，getDefaultProps()的结果会被缓存。可以直接使用props，而不必手动编写一些重复或无意义的代码。</p>
<h3 id="传递Props的小技巧">传递Props的小技巧</h3><p>有一些常用的React组件只是对HTML做简单扩展。通常，希望少写点代码把传入组件的props复制到对应的HTML元素上，可以使用JSX的spread语法：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CheckLink = React.createClass(&#123;</span><br><span class="line">	render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		&#123;<span class="comment">/*会把CheckLink所有的props复制到&lt;a&gt;标签上面*/</span>&#125;</span><br><span class="line">		<span class="keyword">return</span> &lt;a &#123;...<span class="keyword">this</span>.props&#125;&gt;&#123;<span class="keyword">this</span>.props.children&#125;&lt;/a&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">	&lt;CheckLink href=<span class="string">'/checked.html'</span>&gt;</span><br><span class="line">		Click <span class="keyword">here</span></span><br><span class="line">	&lt;/CheckLink&gt;,</span><br><span class="line">	document.querySelector(<span class="string">'#container'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="Mixins">Mixins</h3><p>组件是React里复用代码的最佳方式，但有时一些复杂的组件间也需要共用一些功能。有时会被称为跨切面关注点。React使用mixins来解决此类问题。</p>
<p>一个通用的场景是：一个组件需要定期更新。用setInterval()很容易实现，但当不需要它的时候取消定时器来节约内存是非常重要的。React提供了<a href="http://baizn.github.io/2016/01/28/React%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">生命周期方法</a>来告知组件创建或销毁的时间。下面实现一个简单的mixin，使用setInterval()并保证在组件销毁时清理定时器。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SetIntervalMixin = &#123;</span><br><span class="line">	componentWillMount: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.intervals = [];</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	setInterval: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.intervals.push(setInterval.apply(<span class="literal">null</span>, arguments));</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	componentWillUnmount: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.intervals.map(clearInterval);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TickTock = React.createClass(&#123;</span><br><span class="line">	mixins: [SetIntervalMixin], <span class="comment">//引用mixin</span></span><br><span class="line">	getInitialState: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			second: <span class="number">0</span></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	componentDidMount: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.setInterval(<span class="keyword">this</span>.tick, <span class="number">1000</span>); <span class="comment">//调用mixin的setInterval方法</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	tick: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.setState(&#123;</span><br><span class="line">			second: <span class="keyword">this</span>.state.second + <span class="number">1</span></span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;p&gt;React has been running <span class="keyword">for</span> &#123;<span class="keyword">this</span>.state.second&#125; seconds.&lt;/p&gt;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">	&lt;TickTock /&gt;,</span><br><span class="line">	document.querySelector(<span class="string">'#container'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>关于mixin值得一提的优点是，如果一个组件使用了多个mixin，并且有多个mixin定义了同样的生命周期方法（多个mixin都需要在组件销毁时做资源清理操作），所有这些生命周期方法都保证会被执行到。方法执行的顺序是：首先按mixin引入顺序执行mixin里的方法，最后执行组件内定义的方法。</p>
<h3 id="ES6_Classes">ES6 Classes</h3><p>你也可以把React组件作为一个普通的JS类来定义。如使用ES6的class语法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloReact</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="keyword">return</span> &lt;div&gt;<span class="type">Hello</span> &#123;<span class="keyword">this</span>.props.name&#125;&lt;/div&gt;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ReactDOM</span>.render(&lt;<span class="type">HelloReact</span> name=<span class="symbol">'reac</span>t' /&gt;, document.body);</span><br></pre></td></tr></table></figure>
<p>该API类似于没有getInitialState方法的React.createClass。不再单独提供一个getInitialState方法，需要在构造方法中设置state属性。</p>
<p>另一个区别是propTypes和defaultProps作为属性被定义在构造方法中而不是class内部。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	constructor(props) &#123;</span><br><span class="line">		<span class="keyword">super</span>(props);</span><br><span class="line">		<span class="keyword">this</span>.state = &#123;</span><br><span class="line">			count: props.initialCount</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tick() &#123;</span><br><span class="line">		<span class="keyword">this</span>.setState(&#123;</span><br><span class="line">			count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;div onClick=&#123;<span class="keyword">this</span>.tick.bind(<span class="keyword">this</span>)&#125;&gt;</span><br><span class="line">				<span class="type">Clicks</span>: &#123;<span class="keyword">this</span>.state.count&#125;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Counter</span>.propTypes = &#123;</span><br><span class="line">	initialCount: <span class="type">React</span>.<span class="type">PropTypes</span>.number</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Counter</span>.defaultProps = &#123;</span><br><span class="line">	initialCount: <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="没有自动绑定">没有自动绑定</h3><p>如普通的ES6类，这些方法都遵循相同的语义，这意味着它们不会自动绑定到这个实例上面。你必须显式地使用bind(this)或箭头函数 =&gt;。</p>
<h3 id="没有Mixin">没有Mixin</h3><p>可惜的是ES6不再支持任何Mixin。因此，当你使用ES6的classes来开发React应用时不再支持mixins。相反，我们正在努力使得支持类似的用例更容易而不是混入mixins。</p>
<h3 id="无状态的Functions">无状态的Functions</h3><p>你可以像定义一个普通的JS函数那样定义React类。如使用无状态的函数语法。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloReact</span><span class="params">(props)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &lt;div&gt;Hello &#123;props.name&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;HelloReact name=<span class="string">'react'</span> /&gt;, document.body);</span><br></pre></td></tr></table></figure>
<p>或使用ES6的箭头函数。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var HelloReact = <span class="function"><span class="params">(props)</span> =&gt;</span> &lt;div&gt;Hello &#123;props.name&#125;&lt;/div&gt;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;HelloReact name=<span class="string">'react'</span> /&gt;, <span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure>
<p>这个简单的组件API适用于带有props的纯函数的组件。这些组件不能有内部状态，没有后续实例，并且没有组件生命周期方法。它们是根据输入转化的纯函数，无副作用。但是，仍然可以指定propTypes和defaultProps，然后将其设置为该函数的属性。就类似于使用ES6类时那样设置。</p>
<blockquote>
<p>因为无状态的函数没有后续的实例，因此不能在无状态函数的组件上附加ref属性。通常情况下，这并不是什么问题，因此无状态的函数不提供必须的API。没有必须的API，对一个实例也没有太多的操作。如果用户想在无状态的函数组件中找DOM节点，那么无状态的组件必须包裹在一个有状态组件中（如ES6的类组件），并且在包裹的组件上附加ref属性。</p>
</blockquote>
<p>理想状态下，大多数的组件应该都是无状态的函数，因为在React核心内部，这些无状态的函数组件会流动更快。这只是在条件允许的情况下的一种推荐模式。</p>

      
      

      <!-- page.path 表示不含根路径的页面网址。还有数种方式可以匹配页面，在此不赘述。 -->
        
    </div>
    
    <div class="article-info article-info-index">
      
      

      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Component/">Component</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/可复用组件/">可复用组件</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>










  
    <article id="post-翻译-React顶层API" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/28/翻译-React顶层API/" class="article-date">
  	<time datetime="2016-01-28T06:41:27.000Z" itemprop="datePublished">2016-01-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/28/翻译-React顶层API/">[翻译]React顶层API</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="React">React</h2><p>React是React库的入口。如果使用的是预编译包，则React是全局的；如果使用的CommonJS模块，则可以使用require()函数引入React。</p>
<h3 id="React-Component">React.Component</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span></span></span><br></pre></td></tr></table></figure>
<p>当使用ES6的class定义React组件的时候，React Component是所有组件的基类。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloReact</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="keyword">return</span> &lt;div&gt;hello &#123;<span class="keyword">this</span>.props.name&#125;&lt;/div&gt;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">ReactDOM</span>.render(&lt;<span class="type">HelloReact</span> name=<span class="symbol">'reac</span>t'/&gt;, document.body);</span><br></pre></td></tr></table></figure>
<h3 id="React-createClass">React.createClass</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReactClass <span class="title">createClass</span>(<span class="params"><span class="keyword">object</span> specification</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>创建一个组件类，并作出定义。组件实现了render()方法，该方法返回一个子级。该子级可能包含很深的子级结构。组件与标准原型的不同之处在于，不需要使用new来实例化。组件是一种很方便的封装，可以在后台创建实例（通过new）。</p>
<p>更多关于定义组件对象的信息，参考<a href="http://baizn.github.io/2016/01/11/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3/">React组件生命周期</a>。</p>
<h3 id="React-createElement">React.createElement</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReactElement</span> createElement(</span><br><span class="line">	string/<span class="type">ReactClass</span> <span class="class"><span class="keyword">type</span>,</span><br><span class="line"></span>	[<span class="class"><span class="keyword">object</span> <span class="title">props</span>],</span><br><span class="line"></span>	[children ...]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>根据指定的类型，创建并返回一个ReactElement。type参数可以是一个html标签名字符串（如div，span等），或者是ReactClass（通过React.createClass创建）。</p>
<h3 id="React-cloneElement">React.cloneElement</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReactElement <span class="function">cloneElement</span>(</span><br><span class="line">	ReactElement element,</span><br><span class="line">	<span class="attr_selector">[object props]</span>,</span><br><span class="line">	<span class="attr_selector">[children ...]</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>克隆element元素并返回一个新的ReactElement。得到的新ReactElement的props是原始元素的props和新props的浅合并的结果。新的children将替换现有的children。不同于React.addons.cloneWithProps，原始元素的key和ref都将被保留下来。合并props时没有任何特殊的行为，参考<a href="">v0.13.RC2博客</a>了解更多信息。</p>
<h3 id="React-createFactory">React.createFactory</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">factoryFunction createFactory(</span><br><span class="line">	<span class="type">string</span>/ReactClass <span class="operator">type</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>返回一个生成指定类型ReactElements的函数，比如React.createElement，type参数可以是一个html标签名的字符串（如div，span等）或是ReactClass。</p>
<h3 id="React-isValidElement">React.isValidElement</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean <span class="function"><span class="title">isValidElement</span><span class="params">(* object)</span></span></span><br></pre></td></tr></table></figure>
<p>验证参数对象是否为ReactElement类型。</p>
<h3 id="React-DOM">React.DOM</h3><p>React.DOM利用React.createElement为DOM组件进行了封装，只能使用于不使用JSX的情况下。比如：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.DOM.<span class="keyword">div</span>(<span class="keyword">null</span>, <span class="string">'hello react'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="React-PropTypes">React.PropTypes</h3><p>React.PropTypes所包括的类型用于组件的propTypes对象，目的是为了监测被传递到子组件中的props类型。有关propTypes的更多信息请参考<a href="http://baizn.github.io/2016/01/27/React%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%BB%84%E4%BB%B6/">可重用组件</a>。</p>
<h3 id="React-Children">React.Children</h3><p>React.Children提供了处理this.props.children不透明数据结构的实用工具方法。</p>
<h4 id="React-Children-map">React.Children.map</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array React<span class="class">.Children</span><span class="class">.map</span>(<span class="tag">object</span> children, function fn [, <span class="tag">object</span> thisArg])</span><br></pre></td></tr></table></figure>
<p>在所包含的children中的每一个直接child上为thisArg调用fn函数。如果children是嵌套对象或数组则会遍历：fn函数不会被传递到容器对象中；如果children是null或undefined将返回null或undefined，而不是一个数组。</p>
<h4 id="React-Children-forEach">React.Children.forEach</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React<span class="class">.Children</span><span class="class">.forEach</span>(<span class="tag">object</span> children, function fn [, <span class="tag">object</span> thisArg])</span><br></pre></td></tr></table></figure>
<p>类似React.Children.map，但不会返回数组。</p>
<h4 id="React-Children-count">React.Children.count</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number React<span class="class">.Children</span><span class="class">.count</span>(<span class="tag">object</span> children)</span><br></pre></td></tr></table></figure>
<p>返回children中的组件总数，等于map或forEach的回调函数被调用的次数。</p>
<h4 id="React-Children-only">React.Children.only</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">object</span> React<span class="class">.Children</span><span class="class">.only</span>(<span class="tag">object</span> children)</span><br></pre></td></tr></table></figure>
<p>返回children中惟一的child，否则抛出错误。</p>
<h4 id="React-Children-toArray">React.Children.toArray</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array React<span class="class">.Children</span><span class="class">.toArray</span>(<span class="tag">object</span> children)</span><br></pre></td></tr></table></figure>
<p>返回将children的不透明数据结构转换为以每个child的key所组成的数组。如果你想在render方法中操控children的集合，特别是你希望在它向下传递之前重新排列或裁剪this.props.children时很有用。</p>
<h2 id="ReactDOM">ReactDOM</h2><p>react-dom包在应用程序的顶层提供了一些特定的DOM方法，如果需要，可以作为备用途径在React模型外部使用，大部分的组件不应该使用这个模块。</p>
<h3 id="ReactDOM-render">ReactDOM.render</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReactComponent render(</span><br><span class="line">	ReactElement <span class="keyword">element</span>,</span><br><span class="line">	DOMElement container,</span><br><span class="line">	[<span class="function"><span class="keyword">function</span> <span class="title">callbacl</span>]</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>渲染一个ReactElement到DOM提供的container上，并返回一个组件的引用（返回null或无状态的组件）。</p>
<p>如果ReactElement已经被渲染到container中，只有DOM上发生变化时候才会重新渲染，以反映React组件的最新状态。</p>
<p>如果提供了可选的回调函数，它会在组件渲染或更新完成后执行。</p>
<blockquote>
<p>ReactDOM.render()控制你传递给容器节点的内容。当第一次调用时候，容器中任何已有的DOM元素都会被替换掉。以后的调用都会使用React DOM的diff算法进行高效的更新。</p>
<p>ReactDOM.render()不修改容器节点（只修改容器的子节点），将来可能会是在现有的DOM节点中插入组件而不覆盖已有的子组件。</p>
</blockquote>
<h3 id="ReactDOM-unmountComponentAtNode">ReactDOM.unmountComponentAtNode</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean <span class="function"><span class="title">unmountComponentAtNode</span><span class="params">(DOMElement container)</span></span></span><br></pre></td></tr></table></figure>
<p>从DOM中删除已经加载了的React组件，并清理它的事件处理程序和state。如果在容器中没有加载任何组件，调用此方法什么都不做；如果组件被卸载了则返回ture，如果没有组件卸载则返回false。</p>
<h3 id="ReactDOM-findDOMNode">ReactDOM.findDOMNode</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMElement <span class="function"><span class="title">findDOMNode</span><span class="params">(ReactComponent component)</span></span></span><br></pre></td></tr></table></figure>
<p>如果该组件已经被加载到DOM中，则返回对应的原生浏览器DOM元素。这个方法用于读取DOM的值，比如表单字段，并进行DOM验证。大多数情况下，可以在DOM节点上附加一个ref属性，避免所有情况下都使用findDOMNode。当render返回null或false时，findDOMNode返回null。</p>
<blockquote>
<p>findDOMNode()是用于访问底层DOM节点的备用通道，大多数情况下，不鼓励使用该方法，因为它破坏了组件的抽象化。</p>
<p>findDOMNode()只适用于已经加载的组件（即已放置在DOM中的组件）。如果你试图在还没有被加载的组件上（比如在一个还没有被创建的组件的render()中调用findDOMNode()，）调用该方法将会抛出一个异常。</p>
<p>findDOMNode()不能被用于无状态的组件上。</p>
</blockquote>
<h2 id="ReactDOMServer">ReactDOMServer</h2><p>react-dom/server包允许你在服务端渲染组件。</p>
<h3 id="ReactDOMServer-renderToString">ReactDOMServer.renderToString</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string <span class="function"><span class="title">renderToString</span><span class="params">(ReactElement element)</span></span></span><br></pre></td></tr></table></figure>
<p>渲染一个ReactElement为原始的HTML，这应该只用于服务端。React将返回一个HTML字符串。你可以使用该方法在服务器上生成HTML，然后将这些标记发送给客户端，这样可以加快页面首次加载速度，并让搜索引擎能获取到页面从而达到搜索引擎优化的目的。</p>
<p>如果在一个已有服务端渲染标记的节点上调用ReactDOM.render()，React将会保留该节点，并且仅绑定事件处理器，保证有一个高效的首屏加载体验。</p>
<h3 id="ReactDOMServer-renderToStaticMarkup">ReactDOMServer.renderToStaticMarkup</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string <span class="function"><span class="title">renderToStaticMarkup</span><span class="params">(ReactElement element)</span></span></span><br></pre></td></tr></table></figure>
<p>类似renderToString，除了不会产生额外的DOM属性，如data-react-id，因为这些属性仅在React内部使用。如果想用React做一个简单的静态页面生成器，这将很有用，因为丢掉了额外的属性，节省了很多子节。</p>

      
      

      <!-- page.path 表示不含根路径的页面网址。还有数种方式可以匹配页面，在此不赘述。 -->
        
    </div>
    
    <div class="article-info article-info-index">
      
      

      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/API/">API</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React顶层API/">React顶层API</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>










  
    <article id="post-使用ES6开发React" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/14/使用ES6开发React/" class="article-date">
  	<time datetime="2016-01-14T09:19:27.000Z" itemprop="datePublished">2016-01-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/14/使用ES6开发React/">使用ES6开发React</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="使用ES6开发React">使用ES6开发React</h2><p>开发React项目使用ES6的语法会带来很多便利。</p>
<h3 id="Class">Class</h3><p>使用ES6语法，定义React组件时候使用class关键字代替ES5中的React.createClass方法，可以通过继承React.Component定义一个React组件。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReact</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;h2&gt;<span class="type">Hello</span> <span class="type">React</span>!&lt;/h2&gt;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在定义React组件的时候，你有多了一种选择，ES5或ES6写法</p>
<p>对于同一个组件，不同写法如下。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5定义React组件</span></span><br><span class="line"><span class="keyword">var</span> <span class="type">MyReact</span> = <span class="type">React</span>.createClass(&#123;</span><br><span class="line">	handleChange: function() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;,</span><br><span class="line">	render: function() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6定义React组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReact</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	handleChange() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	render() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过ES6语法定义React组件，我们可以少写两个括号，一个后分号，省略了方法声明时的冒号及function关键字等。</p>
<p>当使用class定义React组件时，所有的生命周期方法都可以使用，class的constructor方法可以替代componentWillMount方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5定义React组件</span></span><br><span class="line"><span class="keyword">var</span> <span class="type">MyReact</span> = <span class="type">React</span>.createClass(&#123;</span><br><span class="line">	componentWillMount: function() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6定义React组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReact</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	constructor(props) &#123;</span><br><span class="line">		<span class="keyword">super</span>(props);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性初始化">属性初始化</h3><p>在ES6的class里面，prop types和props的默认值是作为其静态属性的。prop types，默认props及组件的初始state可以使用ES7的属性初始化（property initializers）定义。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="keyword">var</span> <span class="type">MyReact</span> = <span class="type">React</span>.createClass(&#123;</span><br><span class="line">	getDefaultProps: function() &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			name: <span class="symbol">'Reac</span>t'</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	getInitialState: function() &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			loading: <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	propTypes: &#123;</span><br><span class="line">		name: <span class="type">React</span>.<span class="type">PropTypes</span>.string.isRequired,</span><br><span class="line">		loading: <span class="type">React</span>.<span class="type">PropTypes</span>.bool.isRequired</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReact</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	static defaultProps = &#123;</span><br><span class="line">		name: <span class="symbol">'Reac</span>t'</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static propTypes = &#123;</span><br><span class="line">		name: <span class="type">React</span>.<span class="type">PropTypes</span>.string.isRequired,</span><br><span class="line">		loading: <span class="type">React</span>.<span class="type">PropTypes</span>.string.isRequired</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	state = &#123;</span><br><span class="line">		loading: <span class="keyword">this</span>.props.name</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES7的初始化操作是在构造函数中，即引用的是类的构造函数中的实例。因此state的初始值仍可以依赖this.props。不在需要在getter方法中定义默认props和state对象了。</p>
<h3 id="箭头函数">箭头函数</h3><p>使用React.createClass方法定义组件的时候，组件的实例方法完成一些额外的绑定工作，在它们内部，this关键字引用的组件实例会有问题。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this自动绑定</span></span><br><span class="line"><span class="keyword">var</span> MyReact = React.crateClass(&#123;</span><br><span class="line">	handleChange: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//this引用的组件实例</span></span><br><span class="line">		<span class="keyword">this</span>.setState(&#123;</span><br><span class="line">			loading: <span class="literal">true</span></span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>不使用React.createClass方法，使用ES6的class语法定义组件时候，当需要时候我们可以手动绑定实例方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要时候手动绑定</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReact</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	constructor(props) &#123;</span><br><span class="line">		<span class="keyword">super</span>(props);</span><br><span class="line">		<span class="comment">//onChange与组件实例手动绑定</span></span><br><span class="line">		<span class="keyword">this</span>.onChange = <span class="keyword">this</span>.onChange.bind(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	onChange(state) &#123;</span><br><span class="line">		<span class="comment">//this引用的是组件实例</span></span><br><span class="line">		<span class="keyword">this</span>.setState(state);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>幸运的是通过结合ES6的两个功能：箭头函数和属性初始化，绑定到组件实例变得轻而易举。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReact</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	onChange = (state) =&gt; &#123;</span><br><span class="line">		<span class="comment">//this引用的是组件实例</span></span><br><span class="line">		<span class="keyword">this</span>.setState(state);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6箭头函数和其代码体共享同一个this，ES7的属性初始化在同一作用域。</p>
<h3 id="动态属性名和模板字符串">动态属性名和模板字符串</h3><p>给一个对象动态添加属性。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var MyReact = React.createClass(&#123;</span><br><span class="line">	<span class="keyword">on</span>Change: function(inputName, e) &#123;</span><br><span class="line">		var <span class="keyword">state</span>ToSet = &#123;&#125;;</span><br><span class="line">		<span class="keyword">state</span>ToSet[inputName + 'value'] = e.target.value;</span><br><span class="line">		this.<span class="built_in">set</span>State(<span class="keyword">state</span>ToSet);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当我们要动态添加的对象属性名称由运行时JavaScript表达式决定时候，我们使用模板字符串来设置属性。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReact</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	onChange(inputName, e) &#123;</span><br><span class="line">		<span class="keyword">this</span>.setState(&#123;</span><br><span class="line">			[`$&#123;inputName&#125;value`]: e.target.value</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解构与传播属性">解构与传播属性</h3><p>通常，在编写组件的时候，我们可能都会想着把父组件的props传递给子组件，但并不是所有的props。结合ES6的解构和JSX传播属性，很容易实现该功能。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReact</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">React</span>.<span class="title">Component</span> &#123;</span></span><br><span class="line">	render() &#123;</span><br><span class="line">		<span class="comment">//...others表示除cname外的其它属性</span></span><br><span class="line">		const &#123; cname, ...others&#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;div className=&#123;cname&#125;&gt;</span><br><span class="line">				&lt;<span class="type">Children</span> &#123;...others&#125; /&gt;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
      

      <!-- page.path 表示不含根路径的页面网址。还有数种方式可以匹配页面，在此不赘述。 -->
        
    </div>
    
    <div class="article-info article-info-index">
      
      

      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/">ES6+</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>










  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2016 baizn
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的静态博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减双栏 Hexo 博客主题">Yelee</a> by MOxFIVE
        </div>
    </div>
    <div class="visit">
      <span id="busuanzi_container_site_pv" style='display:none'>
        <span id="site-visit" >本站到访数: 
        <span id="busuanzi_value_site_uv"></span>
        </span>
      </span>
      <span id="busuanzi_container_page_pv" style='display:none'>
        <span id="page-visit">, 本页阅读量: 
        <span id="busuanzi_value_page_pv"></span>
        </span>
      </span>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>

  <style type="text/css">
    body {
      background: lightgray;
    }
    #container .left-col {
      background: white;
    }
    .article-inner {
      background: white;
    }
    .post-nav-button {
      background: #ececec;
    }
    #header .header-nav .social #GitHub {
      background-color: #bfd3ec;
    }
  </style>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
<a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
<a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>